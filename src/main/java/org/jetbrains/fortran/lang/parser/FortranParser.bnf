{
  parserClass='org.jetbrains.fortran.lang.parser.FortranParser'
  implements='org.jetbrains.fortran.lang.psi.FortranCompositeElement'
  extends='org.jetbrains.fortran.lang.psi.impl.FortranCompositeElementImpl'
  parserUtilClass='org.jetbrains.fortran.lang.parser.FortranParserUtil'

  elementTypeHolderClass='org.jetbrains.fortran.lang.FortranTypes'
  elementTypeClass='org.jetbrains.fortran.lang.psi.FortranCompositeElementType'
  tokenTypeClass='org.jetbrains.fortran.lang.psi.FortranTokenType'

  psiClassPrefix='Fortran'
  psiImplClassSuffix='Impl'
  psiPackage='org.jetbrains.fortran.lang.psi'
  psiImplPackage='org.jetbrains.fortran.lang.psi.impl'

  generateTokenAccessors=true
  tokens=[
    EQ        = '='
    EQEQ      = 'regexp:==|.eq.'
    NEQ       = 'regexp:/=|.neq.'
    COLON     = ':'
    COLONCOLON = '::'
    PLUS      = '+'
    MINUS     = '-'
    MUL       = '*'
    POWER     = '**'
    DIV       = '/'
    DIVDIV    = '//'
    LPAR      = '('
    RPAR      = ')'
    LBRACKET  = '['
    RBRACKET  = ']'
    ARRAYLBR  = '(/'
    ARRAYRBR  = '/)'
    COMMA     = ','
    DOT       = '.'
    DOLLAR    = '$'
    PERC      = '%'

    LT        = 'regexp:<|.lt.'
    LE        = 'regexp:<=|.le.'
    GT        = 'regexp:>|.gt.'
    GE        = 'regexp:>=|.ge.'
    QUEST     = '?'
    UNDERSCORE = '_'
    AMPERSAND = '&'

    LOGICAL_EQ  = '.eqv.'
    LOGICAL_NEQ = '.neqv.'
    AND         = '.and.'
    OR          = '.or.'
    NOT         = '.not.'

    TRUE  = '.true.'
    FALSE = '.false.'

    POINTER_ASSMNT = '=>'

    // for the external rule
    LABEL = 'LABEL'
    LABELED_DO_CONSTRUCT = 'LABELED_DO_CONSTRUCT'
    LABEL_DO_STMT = 'LABEL_DO_STMT'
    DO_TERM_ACTION_STMT = 'DO_TERM_ACTION_STMT'
    IDENTIFIER = 'identifier'
  ]

  extends(".*expr")=expr
  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"
}

file ::= program

// keywords parsing list for keywords parsing as identifiers
private abstract_      ::= abstract     | <<parseKeyword 'ABSTRACT'>>
private accept_        ::= accept       | <<parseKeyword 'ACCEPT'>>
private all_           ::= all          | <<parseKeyword 'ALL'>>
private allocate_      ::= allocate     | <<parseKeyword 'ALLOCATE'>>
private allocatable_   ::= allocatable  | <<parseKeyword 'ALLOCATABLE'>>
private assign_        ::= assign       | <<parseKeyword 'ASSIGN'>>
private assignment_    ::= assignment   | <<parseKeyword 'ASSIGNMENT'>>
private associate_     ::= associate    | <<parseKeyword 'ASSOCIATE'>>
private asynchronous_  ::= asynchronous | <<parseKeyword 'ASYNCHRONOUS'>>
private backspace_     ::= backspace    | <<parseKeyword 'BACKSPACE'>>
private bind_          ::= bind         | <<parseKeyword 'BIND'>>
private block_         ::= blockkwd     | <<parseKeyword 'BLOCKKWD'>>
private blockdata_     ::= blockdata    | <<parseKeyword 'BLOCKDATA'>>
private byte_          ::= byte         | <<parseKeyword 'BYTE'>>
private call_          ::= call         | <<parseKeyword 'CALL'>>
private case_          ::= case         | <<parseKeyword 'CASE'>>
private character_     ::= character    | <<parseKeyword 'CHARACTER'>>
private class_         ::= classkwd     | <<parseKeyword 'CLASSKWD'>>
private close_         ::= close        | <<parseKeyword 'CLOSE'>>
private codimension_   ::= codimension  | <<parseKeyword 'CODIMENSION'>>
private complex_       ::= complex      | <<parseKeyword 'COMPLEX'>>
private common_        ::= common       | <<parseKeyword 'COMMON'>>
private concurrent_    ::= concurrent   | <<parseKeyword 'CONCURRENT'>>
private contains_      ::= contains     | <<parseKeyword 'CONTAINS'>>
private contiguous_    ::= contiguous   | <<parseKeyword 'CONTIGUOUS'>>
private continue_      ::= continue     | <<parseKeyword 'CONTINUE'>>
private critical_      ::= critical     | <<parseKeyword 'CRITICAL'>>
private cycle_         ::= cycle        | <<parseKeyword 'CYCLE'>>
private data_          ::= data         | <<parseKeyword 'DATA'>>
private deallocate_    ::= deallocate   | <<parseKeyword 'DEALLOCATE'>>
private decode_        ::= decode       | <<parseKeyword 'DECODE'>>
private default_       ::= default      | <<parseKeyword 'DEFAULT'>>
private deferred_      ::= deferred     | <<parseKeyword 'DEFERRED'>>
private dimension_     ::= dimension    | <<parseKeyword 'DIMENSION'>>
private do_            ::= do           | <<parseKeyword 'DO'>>
private double_        ::= double       | <<parseKeyword 'DOUBLE'>>
private doubleprecision_ ::= doubleprecision | <<parseKeyword 'DOUBLEPRECISION'>>
private doublecomplex_ ::= doublecomplex | <<parseKeyword 'DOUBLECOMPLEX'>>
private elemental_     ::= elemental    | <<parseKeyword 'ELEMENTAL'>>
private else_          ::= else         | <<parseKeyword 'ELSE'>>
private elseif_        ::= elseif       | <<parseKeyword 'ELSEIF'>>
private elsewhere_     ::= elsewhere    | <<parseKeyword 'ELSEWHERE'>>
private encode_        ::= encode       | <<parseKeyword 'ENCODE'>>
private end_           ::= end          | <<parseKeyword 'END'>>
private endassociate_  ::= endassociate | <<parseKeyword 'ENDASSOCIATE'>>
private endblock_      ::= endblock     | <<parseKeyword 'ENDBLOCK'>>
private endblockdata_  ::= endblockdata | <<parseKeyword 'ENDBLOCKDATA'>>
private endcritical_   ::= endcritical  | <<parseKeyword 'ENDCRITICAL'>>
private enddo_         ::= enddo        | <<parseKeyword 'ENDDO'>>
private endenum_       ::= endenum      | <<parseKeyword 'ENDENUM'>>
private endfile_       ::= endfile      | <<parseKeyword 'ENDFILE'>>
private endforall_     ::= endforall    | <<parseKeyword 'ENDFORALL'>>
private endfunction_   ::= endfunction  | <<parseKeyword 'ENDFUNCTION'>>
private endif_         ::= endif        | <<parseKeyword 'ENDIF'>>
private endinterface_  ::= endinterface | <<parseKeyword 'ENDINTERFACE'>>
private endmodule_     ::= endmodule    | <<parseKeyword 'ENDMODULE'>>
private endprocedure_  ::= endprocedure | <<parseKeyword 'ENDPROCEDURE'>>
private endprogram_    ::= endprogram   | <<parseKeyword 'ENDPROGRAM'>>
private endselect_     ::= endselect    | <<parseKeyword 'ENDSELECT'>>
private endsubmodule_  ::= endsubmodule | <<parseKeyword 'ENDSUBMODULE'>>
private endsubroutine_ ::= endsubroutine | <<parseKeyword 'ENDSUBROUTINE'>>
private endtype_       ::= endtype      | <<parseKeyword 'ENDTYPE'>>
private endwhere_      ::= endwhere     | <<parseKeyword 'ENDWHERE'>>
private entry_         ::= entry        | <<parseKeyword 'ENTRY'>>
private enum_          ::= enum         | <<parseKeyword 'ENUM'>>
private enumerator_    ::= enumeratorkwd | <<parseKeyword 'ENUMERATORKWD'>>
private error_         ::= error        | <<parseKeyword 'ERROR'>>
private equivalence_   ::= equivalence  | <<parseKeyword 'EQUIVALENCE'>>
private exit_          ::= exit         | <<parseKeyword 'EXIT'>>
private extends_       ::= extends      | <<parseKeyword 'EXTENDS'>>
private external_      ::= externalkwd  | <<parseKeyword 'EXTERNALKWD'>>
private final_         ::= final        | <<parseKeyword 'FINAL'>>
private flush_         ::= flush        | <<parseKeyword 'FLUSH'>>
private forall_        ::= forall       | <<parseKeyword 'FORALL'>>
private formatkwd_     ::= formatkwd    | <<parseKeyword 'FORMATKWD'>>
private formatted_     ::= formatted    | <<parseKeyword 'FORMATTED'>>
private function_      ::= function     | <<parseKeyword 'FUNCTION'>>
private generic_       ::= generic      | <<parseKeyword 'GENERIC'>>
private go_            ::= go           | <<parseKeyword 'GO'>>
private goto_          ::= goto         | <<parseKeyword 'GOTO'>>
private if_            ::= if           | <<parseKeyword 'IF'>>
private images_        ::= images       | <<parseKeyword 'IMAGES'>>
private implicit_      ::= implicit     | <<parseKeyword 'IMPLICIT'>>
private import_        ::= import       | <<parseKeyword 'IMPORT'>>
private impure_        ::= impure       | <<parseKeyword 'IMPURE'>>
private in_            ::= in           | <<parseKeyword 'IN'>>
private include_       ::= include      | <<parseKeyword 'INCLUDE'>>
private inout_         ::= inout        | <<parseKeyword 'INOUT'>>
private integer_       ::= integer      | <<parseKeyword 'INTEGER'>>
private intent_        ::= intent       | <<parseKeyword 'INTENT'>>
private interface_     ::= interface    | <<parseKeyword 'INTERFACE'>>
private intrinsic_     ::= intrinsic    | <<parseKeyword 'INTRINSIC'>>
private inquire_       ::= inquire      | <<parseKeyword 'INQUIRE'>>
private iolength_      ::= iolength     | <<parseKeyword 'IOLENGTH'>>
private is_            ::= is           | <<parseKeyword 'IS'>>
private kind_          ::= kind         | <<parseKeyword 'KIND'>>
private len_           ::= len          | <<parseKeyword 'LEN'>>
private lock_          ::= lock         | <<parseKeyword 'LOCK'>>
private logical_       ::= logical      | <<parseKeyword 'LOGICAL'>>
private memory_        ::= memory       | <<parseKeyword 'MEMORY'>>
private module_        ::= modulekwd    | <<parseKeyword 'MODULEKWD'>>
private name_          ::= namekwd      | <<parseKeyword 'NAMEKWD'>>
private namelist_      ::= namelist     | <<parseKeyword 'NAMELIST'>>
private none_          ::= none         | <<parseKeyword 'NONE'>>
private nonintrinsic_  ::= nonintrinsic | <<parseKeyword 'NONINTRINSIC'>>
private nonoverridable_ ::= nonoverridable | <<parseKeyword 'NONOVERRIDABLE'>>
private nopass_        ::= nopass       | <<parseKeyword 'NOPASS'>>
private nullify_       ::= nullify      | <<parseKeyword 'NULLIFY'>>
private only_          ::= only         | <<parseKeyword 'ONLY'>>
private open_          ::= open         | <<parseKeyword 'OPEN'>>
private operator_      ::= operator     | <<parseKeyword 'OPERATOR'>>
private optional_      ::= optional     | <<parseKeyword 'OPTIONAL'>>
private out_           ::= out          | <<parseKeyword 'OUT'>>
private parameter_     ::= parameter    | <<parseKeyword 'PARAMETER'>>
private pass_          ::= pass         | <<parseKeyword 'PASS'>>
private pause_         ::= pause        | <<parseKeyword 'PAUSE'>>
private pointer_       ::= pointer      | <<parseKeyword 'POINTER'>>
private precision_     ::= precision    | <<parseKeyword 'PRECISION'>>
private print_         ::= print        | <<parseKeyword 'PRINT'>>
private private_       ::= privatekwd   | <<parseKeyword 'PRIVATEKWD'>>
private procedure_     ::= procedure    | <<parseKeyword 'PROCEDURE'>>
private program_       ::= programkwd   | <<parseKeyword 'PROGRAMKWD'>>
private protected_     ::= protected    | <<parseKeyword 'PROTECTED'>>
private public_        ::= publickwd    | <<parseKeyword 'PUBLICKWD'>>
private pure_          ::= pure         | <<parseKeyword 'PURE'>>
private read_          ::= read         | <<parseKeyword 'READ'>>
private real_          ::= real         | <<parseKeyword 'REAL'>>
private recursive_     ::= recursive    | <<parseKeyword 'RECURSIVE'>>
private result_        ::= result       | <<parseKeyword 'RESULT'>>
private return_        ::= returnkwd    | <<parseKeyword 'RETURNKWD'>>
private rewind_        ::= rewind       | <<parseKeyword 'REWIND'>>
private save_          ::= save         | <<parseKeyword 'SAVE'>>
private select_        ::= select       | <<parseKeyword 'SELECT'>>
private sequence_      ::= sequence     | <<parseKeyword 'SEQUENCE'>>
private stop_          ::= stop         | <<parseKeyword 'STOP'>>
private sync_          ::= sync         | <<parseKeyword 'SYNC'>>
private syncall_       ::= syncall      | <<parseKeyword 'SYNCALL'>>
private syncimages_    ::= syncimages   | <<parseKeyword 'SYNCIMAGES'>>
private syncmemory_    ::= syncmemory   | <<parseKeyword 'SYNCMEMORY'>>
private subroutine_    ::= subroutine   | <<parseKeyword 'SUBROUTINE'>>
private submodule_     ::= submodulekwd | <<parseKeyword 'SUBMODULEKWD'>>
private target_        ::= target       | <<parseKeyword 'TARGET'>>
private then_          ::= then         | <<parseKeyword 'THEN'>>
private to_            ::= to           | <<parseKeyword 'TO'>>
private type_          ::= type         | <<parseKeyword 'TYPE'>>
private unformatted_   ::= unformatted  | <<parseKeyword 'UNFORMATTED'>>
private unlock_        ::= unlock       | <<parseKeyword 'UNLOCK'>>
private use_           ::= use          | <<parseKeyword 'USE'>>
private value_         ::= value        | <<parseKeyword 'VALUE'>>
private volatile_      ::= volatile     | <<parseKeyword 'VOLATILE'>>
private wait_          ::= wait         | <<parseKeyword 'WAIT'>>
private where_         ::= where        | <<parseKeyword 'WHERE'>>
private while_         ::= while        | <<parseKeyword 'WHILE'>>
private write_         ::= write        | <<parseKeyword 'WRITE'>>

// Clause 0
// System parts needed for this implementation
// format is *, label or expression, matches all possibilities
parameters_spec ::= !')' (fidentifier '=')? format {
  pin = 1
  recoverWhile = parameter_spec_recover
}
private parameter_spec_recover ::= !(')' | ',')
// Clause 1 (ready)
// R101
private meta list ::= <<param>> ( ',' <<param>> )*
private meta noncomalist ::= <<param>> ( ','? <<param>> )*
// R102 and R103 are trivial
external fidentifier ::= parseIdentifier

private string_literal ::= stringliteral | multiline_string_literal
multiline_string_literal ::= (stringstart (stringmiddle)* stringend)
// Clause 2
// R201
private program ::= (eol | program_unit)*
// R202
private program_unit ::= !<<eof>> (external_subprogram | module | submodule | block_data | include_stmt | main_program ) {
  pin = 1
  recoverWhile = program_unit_recover
}
private program_unit_recover ::= !(eol | end_unit_keys)
private end_unit_keys ::= !assignment_stmt (end_ | endprogram_ | endmodule_
                        | endfunction_ | endsubroutine_ | endsubmodule_)
// R203
private external_subprogram ::= function_subprogram | subroutine_subprogram
// R204 - 206 are included into execution_part_construct to be in block
// We prefer to parse more and then check
// R207
private declaration_construct ::= derived_type_def | entry_stmt | format_stmt | enum_def
                        | interface_block | parameter_stmt | procedure_declaration_stmt
                        | other_specification_stmt | type_declaration_stmt | stmt_function_stmt
// R208 is in R801
// R209
private execution_part_construct ::= !(label? end_block_keys) ( executable_construct | use_stmt
                                     | include_stmt | import_stmt | implicit_stmt | declaration_construct | type_stmt) {
  pin=1
  recoverWhile=block_recover
}
private block_recover ::= !(eol | end_block_keys) // recover doesn't eat what it is not necessary to eat
private end_block_keys ::= !assignment_stmt (end_ | endblock_ | endcritical_ | enddo_ | endfunction_ | endif_ | endmodule_ | endprocedure_
                         | endprogram_ | endselect_ | endsubroutine_ | else_ | elseif_ | endassociate_ | case_ | contains_)
// R210
internal_subprogram_part ::= contains_stmt (eol | internal_subprogram)* { pin = 1 }
// R211
internal_subprogram ::= !(label? (end_unit_keys | endprocedure_)) (function_subprogram | subroutine_subprogram) {
  pin = 1
  recoverWhile=internal_subprogram_recover
}
private internal_subprogram_recover ::= !(eol | end_ | endfunction_ | endsubroutine_ | endprocedure_)
// R212
other_specification_stmt ::=  access_stmt       |  allocatable_stmt |  asynchronous_stmt
                           |  bind_stmt         |  codimension_stmt |  common_stmt
                           |  data_stmt         |  dimension_stmt   |  equivalence_stmt
                           |  external_stmt     |  intent_stmt      |  intrinsic_stmt
                           |  namelist_stmt     |  optional_stmt    |  pointer_stmt
                           |  protected_stmt    |  save_stmt        |  target_stmt
                           |  volatile_stmt     |  value_stmt
                           |  contiguous_stmt
// R213
private executable_construct ::=  action_stmt  | associate_construct | block_construct  | case_construct
                       | critical_construct    | do_construct        | forall_construct | if_construct
                       | select_type_construct | where_construct
// R214
private action_stmt ::= assignment_stmt | pointer_assignment_stmt   | allocate_stmt   | backspace_stmt
                | call_stmt             | close_stmt                | continue_stmt
                | cycle_stmt            | deallocate_stmt           | endfile_stmt
                | error_stop_stmt       | exit_stmt                 | flush_stmt
                | forall_stmt           | goto_stmt                 | if_stmt
                | inquire_stmt          | lock_stmt                 | nullify_stmt
                | open_stmt             | print_stmt
                | read_stmt             | return_stmt               | rewind_stmt
                | stop_stmt             | sync_all_stmt             | sync_images_stmt
                | sync_memory_stmt      | unlock_stmt               | wait_stmt
                | where_stmt            | write_stmt                | arithmetic_if_stmt
                | computed_goto_stmt
                // deleted
                | pause_stmt            | assign_stmt               | assigned_goto_stmt
                // nonstandard
                | accept_stmt           | encode_stmt               | decode_stmt

// R215 is trivial

// Clause 3 (probably ready)
// R301, R302, R303 are implemented is lexer 'name' is replaced by 'identifier'
// R304, R305 are implemented in Clause 7
// R306, R307, R308 are trivial
// R309, R310, R311 are excess
// R312
external label ::= parseLabel

// Clause 4
// R401
private type_param_value ::= '*' | ':' | expr
// R402
private type_spec ::= intrinsic_type_spec | derived_type_spec
// R403
private declaration_type_spec ::= intrinsic_type_spec | (type_ '(' (intrinsic_type_spec | derived_type_spec)')')
                                | (class_ '(' (derived_type_spec | '*') ')')
// R404
intrinsic_type_spec ::= (((integer_ | real_ | complex_ | logical_ | (double_ precision_) | doubleprecision_
                        | (double_ complex_) | doublecomplex_ )
                        (kind_selector | nonstandard_kind_selector)?) | (character_ (char_selector)?) | byte_/* nonstandard type*/)
                        !('=' | '=>' | '[' | '%') { pin = 2 }
// R405
kind_selector ::= '(' (kind_ '=')? expr ')' {pin = 3}
nonstandard_kind_selector ::= '*' expr { pin = 1 }
// R406
signed_int_literal ::= ('+' | '-')? integerliteral
// R407 - 411 are trivial or implemented in lexer
// R412
signed_real_literal ::= ('+' | '-')? (floatingpointliteral | doubleprecisionliteral)
// R412 - 416 are implemented in lexer
// R417
complex_literal ::= '(' ri_part ',' ri_part ')' { pin = 3 }
// R418 - 419
private ri_part ::= signed_int_literal | signed_real_literal | fidentifier
// R420
char_selector ::= length_selector | ('(' len_ '=' type_param_value ',' kind_ '=' expr ')')
                 | ('(' type_param_value ',' (kind_ '=')? expr ')')
                 | ('(' kind_ '=' expr (',' len_ '=' type_param_value)? ')')
// R421
length_selector ::= ('(' (len_ '=')? type_param_value ')') | ('*' char_length (',' !attr_spec)?)
// R422
char_length ::= ('(' type_param_value ')') | integerliteral
// R423 - 424 are implemented in lexer
// R425
derived_type_def ::= derived_type_stmt type_param_def_stmt* private_or_sequence* component_part
                     type_bound_procedure_part? end_type_stmt { pin = 1 }
// R426
derived_type_stmt ::= label? type_ ((',' <<list type_attr_spec>>)? '::')? fidentifier ('(' <<list fidentifier>> ')')? eol { pin = 4 }
// R427
type_attr_spec ::= abstract_ | access_spec | (bind_ '(' fidentifier ')') | (extends_ '(' fidentifier ')')
// R428
private private_or_sequence ::= label? (private_ | sequence_) eol { pin = 2 }
// R429
end_type_stmt ::= label? ((end_ type_) | endtype_) fidentifier? { pin = 2 }
// R430 is trivial
// R431
type_param_def_stmt ::= integer_ (kind_selector)? ',' type_param_attr_spec '::' <<list type_param_decl>>
// R432
type_param_decl ::= fidentifier ('=' expr)?
// R433
type_param_attr_spec ::= kind_ | len_
// R434
component_part ::= (eol | component_def_stmt)*
// R435
component_def_stmt ::= !(label? (type_end_keys | contains_)) label? (data_component_def_stmt | proc_component_def_stmt) {
 pin = 1
 recoverWhile = component_def_stmt_recover
}
private component_def_stmt_recover ::= !(eol | type_end_keys | contains_)
// R436
data_component_def_stmt ::= declaration_type_spec ((',' <<list component_attr_spec>>)? '::')? <<list component_decl>>
// R437
component_attr_spec ::= access_spec | allocatable_ | (codimension_ '[' coarray_spec ']')
                       | contiguous_ | (dimension_ '(' component_array_spec ')') | pointer_
// R438
component_decl ::= fidentifier ('(' component_array_spec ')')? ('[' coarray_spec ']')?
                   ('*' char_length)? (initialization)?
// R439
private component_array_spec ::= <<list explicit_shape_spec>> | <<list deferred_shape_spec>>
// R440
proc_component_def_stmt ::= procedure_ '(' proc_interface? ')'',' <<list proc_component_attr_spec>> '::' <<list proc_decl>> { pin = 1 }
// R441
proc_component_attr_spec ::= pointer_ | (pass_ ('(' fidentifier ')')?) | nopass_ | access_spec
// R442 is the same as R505
// R443 - 444 are trivial
// R445
type_bound_procedure_part ::= contains_stmt private_stmt? (eol | type_bound_proc_binding)*
// R446
private_stmt ::= label? private_ eol { pin = 2 }
// R447
private type_bound_proc_binding ::= !(label? type_end_keys) (type_bound_procedure_stmt | type_bound_generic_stmt | final_procedure_stmt) {
 pin = 1
 recoverWhile = type_proc_recover
}
private type_proc_recover ::= !(eol | type_end_keys)
private type_end_keys ::= !assignment_stmt (end_ | endtype_)
// R448
type_bound_procedure_stmt ::= procedure_ (type_bound_procedure_stmt_part1 | type_bound_procedure_stmt_part2 ) { pin = 1 }
private type_bound_procedure_stmt_part1 ::= '(' fidentifier ')' ',' <<list binding_attr>> '::' <<list fidentifier>> { pin = 1 }
private type_bound_procedure_stmt_part2 ::= ((',' <<list binding_attr>>)? '::')? <<list type_bound_proc_decl>>
// R449
type_bound_proc_decl ::= fidentifier ('=>' fidentifier)?
// R450
type_bound_generic_stmt ::= generic_ (',' access_spec)? '::' generic_spec '=>' <<list fidentifier>> { pin = 1}
// R451
binding_attr ::= (pass_ ('(' fidentifier ')')?) | nopass_ | nonoverridable_ | deferred_ | access_spec
// R452
final_procedure_stmt ::= final_ '::' <<list fidentifier>> { pin = 1 }
// R453
derived_type_spec ::= fidentifier ('(' <<list type_param_spec>> ')')? { pin = 1 }
// R454
type_param_spec ::= (fidentifier '=')? type_param_value
// R455 is in clause 7
// R456
component_spec ::= (fidentifier '=')? component_data_source
// R457
component_data_source ::= expr /*| variable*/ | proc_target
// R458
enum_def ::= enum_def_stmt (eol | enumerator_def_stmt)+ end_enum_stmt { pin = 1 }
// R459
enum_def_stmt ::= label? enum_ ',' bind_ '(' fidentifier ')' eol { pin = 4 }
// R460
enumerator_def_stmt ::= !(label? end_enum_keys) label? enumerator_ ('::')? <<list enumerator>> {
  pin = 1
  recoverWhile = enum_recover
}
private end_enum_keys ::= !assignment_stmt ((end_ enum_) | endenum_)
private enum_recover ::= !(eol | end_enum_keys)
// R461
enumerator ::= fidentifier ('=' expr)?
// R462
end_enum_stmt ::= label? ((end_ enum_) | endenum_) { pin = 2 }
// R463
boz_literal ::= binaryliteral | octalliteral | hexliteral
// R464 - R467 are implemented in lexer
// R468 is in clause 7
// R469
ac_spec ::= ((type_spec '::')? <<list ac_value>>) | (type_spec '::')
// R470 - 471 are trivial
// R472
ac_value ::= ( ac_implied_do | expr) !'=' { pin = 2 }
// R473
ac_implied_do ::= '('<<list ac_value>> ',' id_loop_stmt ')'
// R474 - 475 are trivial

// Clause 5
// R501
type_declaration_stmt ::= declaration_type_spec ((',' attr_spec)* '::')? <<list (entity_decl)>> {pin=1}
// R502
attr_spec ::= access_spec | allocatable_ | asynchronous_ | (codimension_ '[' coarray_spec ']')
             | contiguous_ | (dimension_ '(' array_spec ')') | external_
             | (intent_ '(' intent_spec ')') | intrinsic_ | language_binding_spec
             | optional_ | parameter_ | pointer_ | protected_ | save_ | target_ | value_ | volatile_
// R503
entity_decl ::= fidentifier ('(' array_spec ')')? ('[' coarray_spec ']')?
                ('*' char_length)? initialization? {
                implements='org.jetbrains.fortran.lang.psi.ext.FortranNamedElement'
                }
// R504 is trivial
// R505
private initialization ::= ('=' expr) | ('=>' designator) | ('=>' function_reference) | ('/' <<list data_stmt_value>> '/')
// R506 is trivial
// R507
private access_spec ::= (public_ | private_)
// R508
language_binding_spec ::= bind_ '(' fidentifier (',' name_ '=' expr)? ')'
// R509
private coarray_spec ::= <<list ':'>> | explicit_coshape_spec
// R510 is trivial
// R511
explicit_coshape_spec ::= ((expr ':')? expr ',')* (expr ':')? '*'
// R512 - 513 are trivial
// R514 is probably unused
// R515
private array_spec ::= assumed_size_spec | <<list implied_shape_spec>> | <<list explicit_shape_spec>>
                     | <<list assumed_shape_spec>> | <<list deferred_shape_spec>>
// R516
explicit_shape_spec ::= (expr ':')? expr
// R517 - 518 are trivial
// R519
assumed_shape_spec ::= (expr)? ':'
// R520
deferred_shape_spec ::= ':'
// R521
assumed_size_spec ::= (explicit_shape_spec ',')* (expr ':')? '*'
// R522
implied_shape_spec ::= (expr ':')? '*'
// R523
private intent_spec ::= in_ | out_ | inout_
// R524
access_stmt ::= access_spec (('::')? <<list access_id>>)?
// R525
access_id ::= fidentifier | generic_spec // generic_spec includes identifier
// R526
allocatable_stmt ::= allocatable_ ('::')? <<list allocatable_decl>> { pin = 1 }
// R527
allocatable_decl ::= fidentifier ('(' array_spec ')')? ('[' coarray_spec ']')?
// R528
asynchronous_stmt ::= asynchronous_ ('::')? <<list fidentifier>> { pin = 1 }
// R529
bind_stmt ::= language_binding_spec ('::')? <<list bind_entity>>
// R530
bind_entity ::= fidentifier | ('/' fidentifier '/')
// R531
codimension_stmt ::= codimension_  ('::')? <<list codimension_decl>> { pin = 1 }
// R532
codimension_decl ::= fidentifier '[' coarray_spec ']'
// R533 unused in standard but works
contiguous_stmt ::= contiguous_ ('::')? <<list fidentifier>> { pin = 1 }
// R534
data_stmt ::= data_ <<list data_stmt_set>>
// R535
data_stmt_set ::= <<list data_stmt_object>> '/' <<list data_stmt_value>> '/'
// R536
data_stmt_object ::= variable | data_implied_do
// R537
data_implied_do ::= '(' <<list data_i_do_object>> ',' fidentifier '=' expr ',' expr (',' expr)?  ')'
// R538
data_i_do_object ::= (data_path | data_implied_do) !'=' { pin= 2 }
// R539 is trivial
// R540
data_stmt_value ::= (data_stmt_repeat '*')? data_stmt_constant
// R541
data_stmt_repeat ::= designator | constant
// R542
data_stmt_constant ::= designator | constant | signed_int_literal | signed_real_literal
                     | function_reference | structure_constructor
// R543 - 544 are trivial
// R545
dimension_stmt ::= dimension_ ('::')? fidentifier '(' array_spec ')' (',' fidentifier '(' array_spec ')')* { pin = 1 }
// R546
intent_stmt ::= intent_ '(' intent_spec ')' ('::')? <<list fidentifier>> { pin = 1 }
// R547
optional_stmt ::= optional_ ('::')? <<list fidentifier>> { pin = 1 }
// R548
parameter_stmt ::= standard_parameter_stmt | nonstandard_parameter_stmt
private standard_parameter_stmt ::= parameter_ '(' <<list named_constant_def>> ')' {pin = 3}
private nonstandard_parameter_stmt ::= parameter_  <<list named_constant_def>>  {pin = 2}

// R549
named_constant_def ::= fidentifier '=' expr
// R550
pointer_stmt ::= pointer_ ('::')? <<list pointer_decl>> { pin = 1 }
// R551
pointer_decl ::= fidentifier ('(' <<list deferred_shape_spec>> ')')?
// R552
protected_stmt ::= protected_ ('::')? <<list fidentifier>> { pin = 1 }
// R553
save_stmt ::= save_ (('::')? <<list saved_entity>>)? { pin = 1 }
// R554
saved_entity ::= fidentifier | ('/' fidentifier '/')
// R555 is trivial
// R556
target_stmt ::= target_ ('::')? <<list target_decl>> { pin = 1 }
// R557
target_decl ::= fidentifier ('(' array_spec ')')? ('[' coarray_spec ']')?
// R558
value_stmt ::= value_ ('::')? <<list fidentifier>> { pin = 1 }
// R559
volatile_stmt ::= volatile_ ('::')? <<list fidentifier>> { pin = 1 }
// R560
implicit_stmt ::= implicit_ (<<list implicit_spec>> | none_) { pin = 2 }
// R561
implicit_spec ::= ((integer_ | real_ | complex_ | logical_ | character_ | (double_ precision_) | doubleprecision_ | byte_) '(' <<list letter_spec>> ')')
                 | (declaration_type_spec '(' <<list letter_spec>> ')')
// that's a crutch to parse intrinsic_type_spec without kindparam
// R562
letter_spec ::= fidentifier ('-' fidentifier)? { pin = 1 }
// R563
namelist_stmt ::= namelist_ '/' fidentifier '/' <<list fidentifier>> ((',')? '/' fidentifier '/' <<list fidentifier>>)* { pin = 1 }
// R564 is trivial
// R565
equivalence_stmt ::= equivalence_ <<list equivalence_set>> { pin = 2 }
// R566
equivalence_set ::= '(' equivalence_object ',' <<list equivalence_object>> ')'
// R567
equivalence_object ::= substring | data_path
// R568
common_stmt ::= common_ (('/' fidentifier? '/') | '//')? <<list common_block_object>> ((',')? (('/' fidentifier? '/') | '//') <<list common_block_object>>)* { pin = 1 }
// R569
common_block_object ::= fidentifier ('(' array_spec ')')?

// Clause 6
// R601 is implemented in clause 7
// R602
private variable ::= designator //| expr
// R603 - 607 are trivial
// R608
substring ::= parent_string '(' substring_range ')'
// R609
parent_string ::= data_path | string_literal
// R610
substring_range ::= (expr)? ':' (expr)?
// R611
data_path ::= data_reference_element ('%' data_reference_element)?
// R612
data_reference_element ::= fidentifier ('(' <<list section_subscript>>? ')')? (image_selector)? {
    implements='org.jetbrains.fortran.lang.psi.ext.FortranReferenceElement'
    stubClass = "org.jetbrains.fortran.lang.core.stubs.FortranDataReferenceStub"
    mixin='org.jetbrains.fortran.lang.psi.ext.FortranDataReferenceElementMixin'
    elementTypeFactory = "org.jetbrains.fortran.lang.core.stubs.StubFactoryKt.factory"
}
// R613 - 614 are trivial
// R615 - 618 are excrescent
// R619 is trivial
// R620
section_subscript ::= (fidentifier '=' expr) | subscript_triplet | expr
// R621
subscript_triplet ::= (expr)? ':' (expr)? (':' expr)?
// R622 - 623 are trivial
// R624
image_selector ::= '[' <<list expr>> ']'  { pin = 1 }
// R625
// R626
allocate_stmt ::= allocate_ '(' (type_spec '::')? <<list allocation>> (',' <<list parameters_spec>>)? ')' { pin = 4 }
// R627 is not for parser
// R628 - 630 are trivial
// R631
allocation ::= allocate_object ('(' <<list allocate_shape_spec>> ')')? ('[' allocate_coarray_spec ']')?
// R632
private allocate_object ::= (data_path) !'='
// R633
allocate_shape_spec ::= (expr ':')? expr
// R634 - 635 are trivial
// R636
allocate_coarray_spec ::= ( <<list allocate_coshape_spec>> ',' )? (expr ':')? '*'
// R637
allocate_coshape_spec ::= (expr ':')? expr
// R638
nullify_stmt ::= nullify_ '(' <<list pointer_object>> ')' { pin = 3 }
// R639
pointer_object ::= data_path
// R640
deallocate_stmt ::= deallocate_ '(' <<list allocate_object>> (',' <<list parameters_spec>>)? ')' { pin = 3 }
// R641 is not for parser

// Clause 7
// expressions in bnf grammar must be defined in a special order
// R701 - R722 + R304 + R305 + R601
expr ::= def_binary_operator_expr
       | equiv_expr
       | or_expr
       | and_expr
       | not_expr
       | rel_expr
       | concat_expr
       | add_expr_group
       | mult_expr
       | power_expr
       | def_unary_operator_expr
       | primary

private add_expr_group ::= add_expr | unary_add_expr
def_binary_operator_expr ::= expr defined_binary_op expr { pin = 2 }
defined_binary_op ::= defoperator
equiv_expr  ::= expr ('.eqv.' | '.neqv.') expr { pin = 2 }
or_expr     ::= expr '.or.' expr { pin = 2 }
and_expr    ::= expr '.and.' expr { pin = 2 }
not_expr    ::= '.not.' expr { pin = 1 }
rel_expr    ::= expr rel_op expr { pin = 2 }
private rel_op ::= '.eq.' | '.ne.' | '.lt.' | '.le.' | '.gt.' | '.ge.'
                 | '=='   | '/='   | '<'    | '<='   | '>'    | '>='
concat_expr ::= expr '//' expr { pin = 2 }
add_expr    ::= expr ('+' | '-') expr { pin = 2 }
unary_add_expr ::= ('+' | '-') expr { pin= 2 }
mult_expr   ::= expr ('*' | '/') expr { pin = 2 }
power_expr  ::= expr '**' expr { rightAssociative=true pin = 2 } { extends=expr }
def_unary_operator_expr ::= defined_unary_op expr { pin = 1 }
private defined_unary_op ::= defoperator
private primary ::= constant | designator | (function_reference !'(') | (array_constructor !'(') /*| structure_constructor*/ | paren /*| type_param_inquiry */
paren ::= '(' expr ')' { pin = 1 }
// R455
structure_constructor ::= (fidentifier '(' <<list component_spec>> ')' !'(')
                         | (derived_type_spec ('(' <<list type_param_spec>> ')')?)
// R468
array_constructor ::= ('(/' ac_spec '/)') | ('[' ac_spec ']')
// R601
designator ::= (data_path !"(") | substring
// R304, R305 modified
constant ::= floatingpointliteral | doubleprecisionliteral | integerliteral | complex_literal
            | logical_literal | string_literal | boz_literal
logical_literal ::= truekwd | falsekwd

// R724 - 731 are trivial

// R732
assignment_stmt ::=  designator '=' expr {pin = 2} // it was a variable here in the standard but we don't want to match an expression
// R733
pointer_assignment_stmt ::= pointer_a_with_data_pointer | pointer_a_with_proc_pointer
private pointer_a_with_data_pointer ::= data_pointer_object (('(' <<list bounds_remapping>> ')')
                                | ('(' <<list bounds_spec>>')')?) '=>' variable { pin = 3 }
private pointer_a_with_proc_pointer ::= proc_pointer_object '=>' proc_target { pin = 2 }
// R734
data_pointer_object ::= (fidentifier !("%" | "(")) | (variable /*'%' fidentifier*/)
// R735
bounds_spec ::= expr ':'
// R736
bounds_remapping ::= expr ':' expr
// R737 is trivial
// R738 + R739
proc_pointer_object ::= (fidentifier !("%" | "(")) | (variable/* '%' fidentifier*/)
// R740
proc_target ::= expr | (variable '%' fidentifier) | fidentifier // last two options may be parsed as expr. Need to check later
// R741
where_stmt ::= where_ '(' expr ')' assignment_stmt { pin = 5}
// R742
where_construct ::= where_construct_stmt (label? (eol | where_body_construct))* (masked_elsewhere_stmt (label? (eol | where_body_construct))*)*
                    (elsewhere_stmt (label? (eol | where_body_construct))*)? end_where_stmt { pin = 1 }
// R743
where_construct_stmt ::= (fidentifier ':')? where_ '(' expr ')' eol { pin = 6 }
// R744
private where_body_construct ::= !(label? end_where_keys) (assignment_stmt | where_stmt | where_construct) {
  pin = 1
  recoverWhile = where_recover
}
private where_recover ::= !(eol | end_where_keys)
private end_where_keys ::= !assignment_stmt (end_ | else_ | elsewhere_ | endwhere_)
// R745, R746 are trivial
// R747
masked_elsewhere_stmt ::= label? ((else_ where_) | elsewhere_) '(' expr ')' fidentifier? eol { pin = 3 }
// R748
elsewhere_stmt ::= label? ((else_ where_) | elsewhere_) fidentifier? eol { pin = 3 }
// R749
end_where_stmt ::= label? ((end_ where_) | endwhere_) fidentifier? { pin = 2 }
// R750
forall_construct ::= forall_construct_stmt (label? (eol | forall_body_construct))* end_forall_stmt { pin = 1 }
// R751
forall_construct_stmt ::= (fidentifier ':')? forall_ forall_header eol { pin = 4 }
// R752
forall_header ::= '(' (type_spec '::')? <<list forall_triplet_spec>> (',' expr)? ')' {pin=1}
// R753 + 754 + 755
forall_triplet_spec ::= fidentifier '=' expr ':' expr (':' expr)? {pin=2}
// R756
private forall_body_construct ::= !(label? end_forall_keys) (forall_assignment_stmt | where_construct | where_stmt
                        | forall_construct | forall_stmt) {
  pin = 1
  recoverWhile = forall_recover
}
private forall_recover ::= !(eol | end_forall_keys)
private end_forall_keys ::= !assignment_stmt (end_ | endforall_)
// R757
private forall_assignment_stmt ::= assignment_stmt | pointer_assignment_stmt
// R758
end_forall_stmt ::= label? ((end_ forall_) | endforall_) fidentifier? { pin = 2 }
// R759
forall_stmt ::= forall_ forall_header forall_assignment_stmt { pin = 3 }


// Clause 8
// R801 + R208 we parse statements in any order while the standard has some restrictions. We'll check them in code revisions
block ::= (label? (eol | execution_part_construct))*
// R802
associate_construct ::= associate_stmt block end_associate_stmt { pin = 1 }
// R803
associate_stmt ::= (fidentifier ':')? associate_ <<list association>> eol { pin = 2 }
// R804
association ::= fidentifier '=>' selector { pin = 2 }
// R805
private selector ::= expr | variable
// R806
end_associate_stmt ::= label? ((end_ associate_) | endassociate_) (fidentifier)? { pin = 2 }
// R807
block_construct ::= block_stmt block end_block_stmt { pin = 1 }
// R808
block_stmt ::= (fidentifier ':')? block_ eol { pin = 3 }
// R809
end_block_stmt ::= label? ((end_ block_) | endblock_) (fidentifier)? {pin = 2 }
// R810
critical_construct ::= critical_stmt block end_critical_stmt { pin = 1 }
// R811
critical_stmt ::= (fidentifier ':')? critical_ eol { pin = 2 }
// R812
end_critical_stmt ::= label? ((end_ critical_) | endcritical_) (fidentifier)? { pin = 2 }
// R813 simplified compared to standard
external labeled_do_construct ::= parseLabeledDoConstruct
private do_construct ::= labeled_do_construct | nonlabel_do_construct
// R814
nonlabel_do_construct ::= nonlabel_do_stmt block end_do { pin = 1}
// R815 unused
// R816
//label_do_stmt ::= (identifier ':')? do label loop_control? eol { pin = 3 }
// R817
nonlabel_do_stmt ::= (fidentifier ':')? do_ loop_control? eol { pin = 2 }
// R818
loop_control ::= while_loop_stmt | concurrent_loop_stmt | id_loop_stmt
private id_loop_stmt ::= variable '=' expr ',' expr (',' expr)? {pin=1}
private while_loop_stmt ::= while_ '(' expr ')' {pin=1}
private concurrent_loop_stmt ::= concurrent_ forall_header {pin = 1}
// R819, R820 are trivial
// R821
private end_do ::= end_do_stmt //| continue at the end of a loop is f77 specific feature
// R822
end_do_stmt ::= label? (end_ do_ | enddo_) fidentifier? { pin = 2}
// R823 - 830 are parsed manually
// R831
cycle_stmt ::= cycle_ (fidentifier)? { pin = 1 }
// R832
if_construct ::= if_then_stmt block (else_if_stmt block)* (else_stmt block)? end_if_stmt { pin = 1 }
// R833
if_then_stmt ::= (fidentifier ':')? if_ '(' expr ')' then_ eol { pin = 2 }
// R834
else_if_stmt ::= label? ((else_ if_)|elseif_) '(' expr ')' then_ fidentifier? eol { pin = 2 }
// R835
else_stmt ::= label? else_ fidentifier? eol { pin = 2 }
// R836
end_if_stmt ::= label? ((end_ if_)|endif_) fidentifier? { pin = 2 }
// R837
if_stmt ::= if_ '(' expr ')' action_stmt {pin=5}
// R838
case_construct ::= select_case_stmt (case_stmt block)* end_select_stmt { pin = 1 }
// R839
select_case_stmt ::= (fidentifier ':')? select_ case_ '(' expr ')' eol { pin = 3 }
// R840
case_stmt ::= label? case_ case_selector (fidentifier)? eol { pin = 2 }
// R841
end_select_stmt ::= label? ((end_ select_) | endselect_ ) (fidentifier)? { pin = 2 }
// R842 is trivial
// R843
case_selector ::= ('(' <<list case_value_range>> ')') | default_
// R844
case_value_range ::= (expr ':' expr) | (expr ':') | expr | (':' expr)
// R845 is trivial
// R846
select_type_construct ::= select_type_stmt (type_guard_stmt block)* end_select_stmt { pin = 1 }
// R847
select_type_stmt ::= (fidentifier ':')? select_ type_ '(' (fidentifier '=>')? selector ')' { pin = 3 }
// R848
type_guard_stmt ::= (typeis_guard | classis_guard | classdefault_guard) fidentifier? { pin = 1 }
private typeis_guard ::= type_ is_ '(' type_spec ')' { pin = 1 }
private classis_guard ::= class_ is_ '(' derived_type_spec ')' { pin = 2 }
private classdefault_guard ::= class_ default_ { pin = 2 }
// R849 is a copy of R841
// R850
exit_stmt ::= exit_ (fidentifier)? { pin = 1 }
// R851
goto_stmt ::= ((go_ to_) | goto_) label { pin = 2 }
// R852 deprecated
computed_goto_stmt ::= ((go_ to_) | goto_) '(' <<list label>> ')' (',')? expr { pin = 2 }
// R853 deprecated
arithmetic_if_stmt ::= if_ '(' expr ')' label ',' label ',' label { pin = 5 }
// R854
continue_stmt ::= continue_ { pin = 1 }
// R855
stop_stmt ::= stop_ !("=" | "=>" | '[' | "%") (expr)? { pin = 2 }
// R856
error_stop_stmt ::= error_ stop_ (expr)? { pin = 2 }
// R857 it trivial
// R858
sync_all_stmt ::= ((sync_ all_) | syncall_) ('(' ( <<list parameters_spec>> )? ')')? { pin = 1 }
// R859 is not for parser
// R860
sync_images_stmt ::= ((sync_ images_) | syncimages_) '(' image_set (',' <<list parameters_spec>>)?')' { pin = 1 }
// R861
image_set ::= '*' | expr
// R862
sync_memory_stmt ::= ((sync_ memory_) | syncmemory_) ('(' (<<list parameters_spec>>)? ')')? { pin = 1 }
// R863
lock_stmt ::= lock_ '(' variable (',' <<list lock_stat>>)? ')' { pin = 2 }
// R864
lock_stat ::=  (fidentifier fidentifier '=' variable) | parameters_spec
// lock_stat ::= (acquired lock '=' variable) | sync_stat
// R865
unlock_stmt ::= unlock_ '(' variable (',' <<list parameters_spec>>)? ')' { pin = 1 }
// R866 is trivial

// Clause 9 (ready)
// R901 don't need now
//io_unit ::= '*' | variable | expr
// R902, R903 are trivial
// R904
open_stmt ::= open_ '(' <<list parameters_spec>> ')' {pin = 2}
// R905 is not for parser
// R906, R907 are trivial
// R908
close_stmt ::= close_ '(' <<list parameters_spec>> ')' {pin = 2}
// R909 is not for parser
// R910
read_stmt ::= read_ (io_control_read | format_read) {pin = 1}
private io_control_read ::= '(' <<list parameters_spec>> ')' ','? <<list input_item>>? { pin = 1}
private format_read ::= format (',' <<list input_item>>?)?
// R911
write_stmt ::= write_ '(' <<list parameters_spec>> ')' ','? <<list output_item>>? { pin= 2 }
// R912
print_stmt ::= print_ format ','? <<list output_item>>? { pin = 2 }
// R913 is not for parser
// R914 is trivial
// R915
private format ::= '*' /*| label*/ | expr
// we can match label when it's really an expression, but expression matches a label too
// R916
input_item ::= variable | io_implied_do
// R917
output_item ::= io_implied_do | expr
// R918 + R920
io_implied_do ::= '(' <<list io_implied_do_object>> ',' id_loop_stmt ')' { pin = 4 }
// R919
io_implied_do_object ::= (input_item | output_item) !'=' { pin = 2 }
// R921 (unused maybe)
//dtv_type_spec ::= (type | classkwd) '(' derived_type_spec ')' { pin =1 }
// R922
wait_stmt ::= wait_ '(' <<list parameters_spec>> ')' { pin =1 }
// R923 is not for parser
// R924
backspace_stmt ::= backspace_ (('(' <<list parameters_spec>> ')') | expr ) { pin = 1 }
// R925
endfile_stmt ::= endfile_ (('(' <<list parameters_spec>> ')') | expr) { pin = 1 }
// R926
rewind_stmt ::= rewind_ (('(' <<list parameters_spec>> ')') | expr) { pin = 1}
// R927 + R929 are not for parser
// R928
flush_stmt ::= flush_ (('(' <<list parameters_spec>> ')') | expr) { pin = 1}
// R930
inquire_stmt ::= inquire_ (inquire_with_iolength | ('(' <<list parameters_spec>> ')'))  { pin = 1}
private inquire_with_iolength ::= '(' iolength_ '=' expr /*variable */')' <<list output_item>> { pin = 2}
// R931 is not for parser

// Clause 10
// R1001
format_stmt ::= formatkwd_ (('(' <<noncomalist format_item>>? ')')
              | ('('(<<noncomalist format_item>> ',')? '*' '(' <<noncomalist format_item>> ')'')' )) { pin = 1 }
private format_item ::= dataedit | control_edit | string_literal | (integerliteral? '(' <<list format_item>> ')')
control_edit ::= ":" | (integerliteral? '/') | (signed_int_literal dataedit)
// Clause 11
// R1101
main_program ::= program_stmt? block internal_subprogram_part? end_program_stmt {pin=1}
// R1102 +
program_stmt ::= label? program_ fidentifier eol { pin = 2 }
// R1103 +
end_program_stmt ::=  label? (endprogram_ fidentifier? | end_ (program_ fidentifier?)?) { pin = 2 }
// R1104
module ::= module_stmt block module_subprogram_part? end_module_stmt { pin = 1 }
// R1105
module_stmt ::= label? module_ fidentifier eol { pin = 2 }
// R1106
end_module_stmt ::= label? (endmodule_ fidentifier? | end_ (module_ fidentifier?)?) { pin = 2 }
// R1107
module_subprogram_part ::= contains_stmt (eol | module_subprogram)* { pin = 1 }
// R1108
module_subprogram ::= !(label? (end_ | endmodule_ | endsubmodule_)) (function_subprogram | subroutine_subprogram | separate_module_subprogram | include_stmt) {
  pin = 1
  recoverWhile = module_subprogram_recover
}
private module_subprogram_recover ::= !(eol | end_ | endfunction_ | endsubroutine_ | endprocedure_)
// R1109
use_stmt ::= use_ (use_stmt_only | use_stmt_rename) { pin = 1 }
private use_stmt_rename ::= ((',' module_nature)? '::')? fidentifier (',' <<list rename_stmt>>)?
private use_stmt_only ::= ((',' module_nature)? '::')? fidentifier ',' only_ ':' (<<list only_stmt>>)? { pin = 5 }
// R1110
private module_nature ::= intrinsic_ | nonintrinsic_
// R1111
rename_stmt ::= (fidentifier '=>' fidentifier)
               |(operator_ '(' defoperator ')' '=>' operator_ '(' defoperator ')')
// R1112
only_stmt ::= rename_stmt | generic_spec | fidentifier
// R1113, R1114, R1115 are trivial
// R1116
submodule ::= submodule_stmt block module_subprogram_part? end_submodule_stmt { pin = 1 }
// R1117
submodule_stmt ::= label? submodule_ '(' parent_identifier ')' fidentifier eol { pin = 2 }
// R1118
parent_identifier ::= fidentifier (':' fidentifier)?
// R1119
end_submodule_stmt ::= label? (endsubmodule_ fidentifier? | end_ (submodule_ fidentifier?)?)  { pin = 2 }
// R1120
block_data ::= block_data_stmt block end_block_data_stmt { pin = 1 }
// R1121
block_data_stmt ::= label? (blockdata_ | (block_ data_)) fidentifier? eol { pin = 2 }
// R1122
end_block_data_stmt ::= label? ((endblockdata_ fidentifier?)| (end_ (((block_ data_) | blockdata_) fidentifier?)?)
                      | (endblock_ data_ fidentifier?))  { pin = 2 }

// Clause 12
// R1201
interface_block ::= interface_stmt interface_specification end_interface_stmt { pin = 1 }
// R1202
private interface_specification ::= !endinterface_keys (eol | interface_body | procedure_stmt)* {
pin = 1
recoverWhile = interface_recover
}
private endinterface_keys ::= !assignment_stmt (end_ | endinterface_)
private interface_recover ::= !(eol | endinterface_keys)
// R1203
interface_stmt ::= ((abstract_ interface_) | (interface_ (generic_spec)?)) eol { pin = 1 }
// R1204
end_interface_stmt ::= label? ((end_ interface_) | endinterface_) (generic_spec)? { pin = 2 }
// R1205
interface_body ::= interface_function_body | interface_subroutine_body
private interface_function_body ::= function_stmt block? end_function_stmt { pin = 1 }
private interface_subroutine_body ::= subroutine_stmt block? end_subroutine_stmt { pin = 1 }
// R1206
procedure_stmt ::= (module_)? procedure_ ('::')? <<list fidentifier>> { pin = 2 }
// R1207
generic_spec ::= fidentifier | (operator_ '(' defoperator ')')
              | assignment_ '(' '=' ')' | defined_io_generic_spec
// R1208
defined_io_generic_spec ::= read_ '(' (formatted_ | unformatted_) ')'
                           | write_ '(' (formatted_ | unformatted_) ')'
// R1209
import_stmt ::= import_ ('::'? <<list fidentifier>>)? { pin =1 }
// R1210
external_stmt ::= external_ ('::')? <<list fidentifier>> { pin = 1 }
// R1211
procedure_declaration_stmt ::= procedure_ '(' proc_interface? ')' ((',' proc_attr_spec)* '::')? <<list proc_decl>> { pin = 1 }
// R1212
proc_interface ::= fidentifier | declaration_type_spec
// R1213
proc_attr_spec ::= access_spec | language_binding_spec | (intent_ '(' intent_spec ')')
                  | optional_ | pointer_ | save_
// R1214
proc_decl ::= fidentifier ('=>' proc_pointer_init)?
// R1215 is trivial
// R1216
proc_pointer_init ::= function_reference | fidentifier
// R1217 is trivial
// R1218
intrinsic_stmt ::= intrinsic_ ('::')? <<list fidentifier>> { pin = 1 }
// R1219
function_reference ::= procedure_designator '(' <<list actual_arg_spec>>? ')' { pin = 4 }
// R1220
call_stmt ::= call_ procedure_designator ('(' <<list actual_arg_spec>>? ')')? { pin = 1 }
// R1221
procedure_designator ::= data_path
// R1222
actual_arg_spec ::= (fidentifier '=')? actual_arg
// 1223
actual_arg ::= expr | alt_return_spec // expr matches variable, procedure-name and proc-component-ref
// 1224 deprecated
alt_return_spec ::= '*' label
// R1225
prefix ::= prefix_spec+ { pin = 1 }
// R1226
prefix_spec ::= declaration_type_spec | elemental_ | impure_ | module_ | pure_ | recursive_
// R1227
function_subprogram ::= function_stmt block internal_subprogram_part? end_function_stmt { pin = 1 }
// R1228
function_stmt ::= label? prefix? function_ fidentifier '(' <<list fidentifier>>? ')' suffix? eol { pin = 3 }
// R1229 and R1230 are trivial
// R1231
suffix ::= (language_binding_spec (result_ '(' fidentifier ')')?) | (result_ '(' fidentifier ')' (language_binding_spec)?)
// R1232
end_function_stmt ::= label? ((end_ (function_ fidentifier?)?) | (endfunction_ fidentifier?)) { pin = 2 }
// R1233
subroutine_subprogram ::= subroutine_stmt block internal_subprogram_part? end_subroutine_stmt { pin = 1 }
// R1234
subroutine_stmt ::= label? prefix? subroutine_ fidentifier ('(' <<list dummy_arg>>? ')' language_binding_spec? )? eol { pin = 3 }
// R1235
dummy_arg ::= '*' | fidentifier
// R1236
end_subroutine_stmt ::= label? ((end_ (subroutine_ fidentifier?)?) | (endsubroutine_ fidentifier?)) { pin = 2 }
// R1237
separate_module_subprogram ::= mp_subprogram_stmt block internal_subprogram_part? end_mp_subprogram_stmt { pin = 1 }
// R1238
mp_subprogram_stmt ::= label? module_ procedure_ fidentifier eol { pin = 3 }
// R1239
end_mp_subprogram_stmt ::= label? ((end_ (procedure_ fidentifier?)?) | (endprocedure_ fidentifier?)) { pin = 2}
// R1240
entry_stmt ::= entry_ fidentifier ('(' <<list dummy_arg>>? ')' suffix? )? { pin = 1 }
// R1241
return_stmt ::= return_ (expr)? { pin = 1}
// R1242
contains_stmt ::= label? contains_ eol { pin = 2 }
// R1243
stmt_function_stmt ::= fidentifier '(' <<list fidentifier>>? ')' '=' expr { pin = 5 }

// deleted statements
pause_stmt ::= pause_ (expr)? { pin = 1 }
assign_stmt ::= assign_ label to_ variable { pin = 1 }
assigned_goto_stmt ::= (goto_ | (go_ to_)) fidentifier (','? '(' <<list label>> ')' )?  { pin = 2 }
include_stmt ::= include_ string_literal { pin = 1 }

// nonstandard
accept_stmt ::= accept_  format (',' <<list input_item>>)?  {pin = 1}
encode_stmt ::= encode_ '(' expr ',' format ',' designator (',' <<list parameters_spec>>)?')' <<list output_item>> { pin = 1}
decode_stmt ::= decode_ '(' expr ',' format ',' designator (',' <<list parameters_spec>>)?')' <<list input_item>> { pin = 1 }
type_stmt ::= type_ format (','? <<list output_item>>?) { pin = 3 }
